#include "rage/file/device.h"

#include "rage/paging/resourceheader.h"
#include "common/logger.h"
#include "local.h"
#include "am/integration/memory/address.h"

rage::fiDevice* rage::fiDevice::GetDeviceImpl(ConstString path, bool isReadOnly)
{
#ifdef AM_STANDALONE
	return fiDeviceLocal::GetInstance(); // For now...
#else
	auto getDeviceImpl = gmAddress::Scan(
#if APP_BUILD_2699_16_RELEASE_NO_OPT
		"EB 5A 48 83 3D", "rage::fiDevice::GetDeviceImpl+0x888").GetAt(-0x888)
#else
		"48 89 5C 24 08 88 54 24 10 55 56 57 41 54 41 55 41 56 41 57 48 83")
#endif
		.ToFunc<fiDevice * (ConstString, bool)>();

	fiDevice* device = getDeviceImpl(path, isReadOnly);
	if(!device || String::Equals(device->GetDebugName(), "Local")) // Fall back on our local device
		return fiDeviceLocal::GetInstance();
	return device;
#endif
}

bool rage::fiDevice::FileExists(ConstString path)
{
	fiDevice* device = GetDeviceImpl(path);
	if (!device)
		return false;

	u32 attributes = device->GetAttributes(path);
	return attributes != FI_INVALID_ATTRIBUTES && attributes != FI_ATTRIBUTE_DIRECTORY;
}

bool rage::fiDevice::SafeRead(fiHandle_t file, pVoid buffer, u32 size)
{
	if (size == 0)
		return true;

	u32 totalBytesRead = 0;
	while (true)
	{
		u32 remaining = size - totalBytesRead;
		u32 bytesRead = Read(file, buffer, remaining);
		if (bytesRead == FI_INVALID_RESULT)
			return false;

		totalBytesRead += bytesRead;
		if (totalBytesRead >= size)
			return true;
	}
}

bool rage::fiDevice::SafeWrite(fiHandle_t file, pConstVoid buffer, u32 size)
{
	if (size == 0)
		return true;

	u32 totalBytesRead = 0;
	while (true)
	{
		u32 remaining = size - totalBytesRead;
		u32 bytesRead = Write(file, buffer, remaining);
		if (bytesRead == FI_INVALID_RESULT)
			return false;

		totalBytesRead += bytesRead;
		if (totalBytesRead >= size)
			return true;
	}
}

u32 rage::fiDevice::GetResourceInfo(ConstString path, datResourceInfo& info)
{
	if (GetFileSize(path) < sizeof datResourceHeader)
	{
		AM_ERRF("fiDevice::GetResourceInfo() -> Invalid file (empty / doesn't exists) %s", path);
		return 0;
	}

	u64 offset;
	u32 version = 0;

	fiHandle_t file = OpenBulk(path, offset);
	if (file == FI_INVALID_HANDLE)
	{
		AM_ERRF("fiDevice::GetResourceInfo() -> Can't open %s", path);
		return 0;
	}

	datResourceHeader header{};
	if (ReadBulk(file, offset, &header, sizeof datResourceHeader) != FI_INVALID_RESULT)
	{
		version = header.Version;
		info = header.Info;
	}
	CloseBulk(file);

	return version;
}
